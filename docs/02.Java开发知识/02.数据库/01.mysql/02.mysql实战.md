> 文档内容来自极客时间45讲

## 基础知识


###  sql语句查询的流程

整体架构主要分为`逻辑(service)层` 与 `引擎层` 

![[架构图.png]]

1. 通过身份信息与mysql建立链接
2. 查询缓存中是否存在,缓存一般设置为关闭,因为表内容变动就会重建缓存
3. 通过分析器,判读查询语义是否有问题
4. 优化器优化查询的选择,是否走索引之类的
5. 执行器调用引擎,返回数据
### sql中的日志

`redolog (重做日志)` 和 `binlog` 日志
`redolog`日志是InnDB 引擎独有的,用于支持事务与故障恢复的日志信息,存储的数据是指在数据结构页上做了什么修改,存储空间有限制,容量满时需擦除之前的记录,
`binlog`日志是service层公共的,记录数据逻辑上发生了什么样改变(c字段 +=2),用于定期备份恢复数据的日志,支持追加写.目前常见迁移数据就是采用数据库全量数据+`binlog`恢复的方式.

![[sql更新流程.png]]




### 事务
>同事务将要涉及到对同一行数据的更新操作则会触发锁事件

**事务的级别:**
1. 读未提交:
2. 读已提交: 不同事务只能读到已经提交的内容
3. 可重复读: 事务才处理期中,读到的数据与开始时一样,
4. 串行读: 会对操作加锁:`读锁` , `写锁` ,如果写锁冲突时会串行执行 

InnDB 引擎默认隔离级别就是可重复读，oracle默认级别是可重复读
**可重复读** 与 **读提交** 的区别主要是：可重复读获取的数据是隔离的，是建立事务时的版本。

**事务如何启动**
> 事务不要长期持有,会增加占用空间和内存
1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit. commit work and chain - 提交语句并自动启动下一个事务。回滚语句 - rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

**查找持续时间超过 60s 的事务**
```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```


### 索引
**索引常见的数据模型**
1. key/value 的哈希表模型: **哈希表这种结构适用于只有等值查询的场景**
2. **有序数组**:只适用于静态存储引擎
3. 二叉搜索树
4. InnoDB 使用了 B+ 树索引模型

**索引分类**
**主键索引**  与 **非主键索引**  主键索引存储的是行数据，非主键索引存储的是主键索引的位置。

**覆盖索引**:索引可以设置多个字段,如果查询条件和展示条件都在**联合索引** 或**主键**中,就不用**回表**(去主键索引中查)了
**最左匹配原则:** 查询条件如果与索引最左N个字段吻合,就会走索引,如果索引字段包括全部展示字段,不会触发回表操作
**索引下推** : 关于最左匹配原则,没有匹配到的查询字段在MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉不满足没匹配到字段的查询条件，再进行回表查询，减少回表率，提升检索速度
**实战知识**
count（*）与其它统计相比，效率会高吗：基本相差不大
邮箱账号这种长字符串怎么建立索引：前缀索引/倒叙索引/哈希值索引
为何删除数据不会缩减空间： 删除数据后，数据删除，但占据空间会设为空。解决办法为创建同名新表转移数据

### 锁

#### 分类
1. 全局锁
2. 表锁
3. 行锁
#### 全局锁
对整个库加锁,禁止写入,修改,定义操作,一般用于数据库备份时使用
**使用风险:**
1. 使用主库备份:无法更新,业务停摆
2. 在从库使用: 如果解析还原binglog日志,导致主从差异
3. 
建议使用官方工具备份:官方自带的逻辑备份工具mysqldump，当mysqldump使用参数--single-transaction的时候，会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
#### 表锁
表级锁分为两种:`表锁` ,`元数据锁(DML)`  
**表锁**一般常见于非InnDB引擎,不支持行锁的引擎中,语法为lock tables ... read/write .可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象.
**元数据锁DML**
在访问一个表时自动被加上读/写锁,保证表的读写正确.避免便利查询时,表结构发生变动的情况.
在给表添加字段时,常会因为元数据锁导致数据库宕机挂掉: `写锁`等待`读锁`才能执行,但前方`读锁`可能为长连接一直未关闭,`写锁`后面的`读锁`被阻塞,超时后新建的`读锁`越来越多,导致宕机.

数据增添字段时针对表是否为热点数据进行处理
1. **非热点数据:** 查询information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务,观察表是否存在长事务的连接,手动kill掉此连接
2. **热点表数据:** 通过 NOWAIT/WAIT n设置等待时间

**wait n**参数表示等待n秒后，能锁则锁，不能锁则返回错误信息  
**nowait**参数表示不等待，我现在能锁则锁，不能锁则直接返回错误
```sql

ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 

```


#### 行锁

行锁是由各个引擎实现的,针对行数据加锁的操作.
行锁是在使用时才加上,直到事务提交才释放

1. 将最可能造成锁冲突的地方尽量往后放

**避免死锁检测造成的性能影响**
1. 如果确保业务不会出现死锁,可以临时把死锁检测关掉
2. 控制并发度

### 事务隔离

根据事务级别,承认级别不同:
-   对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
-   对于读提交，查询只承认在语句启动前就已经提交完成的数据；