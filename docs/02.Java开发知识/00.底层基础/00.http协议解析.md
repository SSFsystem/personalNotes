# 协议基础

## 网络传输的流程
请求方 - > (中间件) cdn -> 服务端
cdn 将请求分发给最近的服务器

## 传输协议分层
四层:
链路层
网络互联层 ip
传输层 tcp
应用层

七层:
物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
第三层：网络层，相当于 TCP/IP 里的网际层；
第四层：传输层，相当于 TCP/IP 里的传输层；
第五层：会话层，维护网络中的连接状态，即保持会话和同步；
第六层：表示层，把数据转换为合适、可理解的语法和语义；
第七层：应用层，面向具体的应用传输数据。

## 域名解析
真实计算机使用的是mac地址，mac地址在局域网中映射为一个ip地址，但ip地址记忆困难。域名解析就是为了将域名分析转换为具体的ip地址

### 域名分级
**根域名服务器（Root DNS Server）：**
管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；
**顶级域名服务器（Top-level DNS Server）**：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；
**权威域名服务器（Authoritative DNS Server）**：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。




# 基础篇

## 浏览器到服务器发生了什么
http协议是建立在Tcp/ip协议基础上,所以首先
1. 使用三次握手,建立web服务器器的连接
2. 通过 TCP 发送了一个“GET / HTTP/1.1”请求报文
3. web服务器回复响应,已经接收到请求
4. web服务器根据请求,返回具体内容
5. 浏览器收到内容后,返回一个ack确认
6. 浏览器解析接收到的内容再次循环执行
7. 最后tcp四次挥手关闭连接

## Http 报文内容

http的请求与响应报文基本一致:分为三大部分
1.  起始行（start line）：描述请求或响应的基本信息；
2.  头部字段集合（header）：使用 key-value 形式更详细地说明报文；
3.  消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。
### 起始行:
请求行构成: GET / HTTP/1.1
请求方法 , 请求目标, 版本号
状态行构成:HTTP/1.1 200 OK
版本号 状态码 原因
### 头部字段:
头部字段可以分为:
1. 通用字段:在请求头和响应头里都可以出现；
2. 请求字段: 在请求头和响应头里都可以出现；
3. 响应字段: 仅能出现在响应头里，补充说明响应报文的信息；
4. 实体字段: 它实际上属于通用字段，但专门描述 body 的额外信息。
**举例**
Host 字段告诉服务器这个请求应该由哪个主机来处理(必须有)
**User-Agent**是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，
**Date**字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间
**Server**字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，
**Content-Length**，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。

## 请求方法
目前 HTTP/1.1 规定了八种方法，单词**都必须是大写的形式**
1.  GET：获取资源，可以理解为读取或者下载数据；
2.  HEAD：获取资源的元信息；就是只返回响应头
3.  POST：向资源提交数据，相当于写入或上传数据；
4.  PUT：类似 POST；
5.  DELETE：删除资源；
6.  CONNECT：建立特殊的连接隧道；
7.  OPTIONS：列出可对资源实行的方法；
8.  TRACE：追踪请求 - 响应的传输路径。
注意包含4以后的方法都为扩展方法,有些服务器不支持此种请求方法

## 请求地址
浏览器中的网络地址是URI
URI由两部分组成:URL(**统一资源定位符**)与 URN(**统一资源名**) 
现在因为URL太普及了,经常把**URL** 等同于**URI**
### URI格式
URI 本质上是一个字符串，这个字符串的作用是**唯一地标记资源的位置或者名字**。
1. scheme: 方案名\协议名
2. :// 分隔符
3. host:port:   主机名加端口号
4. path: 标记资源所在位置
5. query: 表示对资源附加的额外要求；

### URI 编码

URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式
非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”


## 响应报文 - 响应头
服务器收到请求后,必定返回响应报文
响应报文由响应体和响应头
响应头由状态行和头字段构成
#### 状态行
由 `协议版本号` \ `状态码` \ `结果` 组成,其中对我们最有用的就是状态码
RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。
-   1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
-   2××：成功，报文已经收到并被正确处理；
-   3××：重定向，资源位置发生变动，需要客户端重新发送请求；
-   4××：客户端错误，请求报文有误，服务器无法处理；
-   5××：服务器错误，服务器在处理请求时内部发生了错误。

##### 1xx
这种状态码很少见,有可能见到的是,“**101 Switching Protocols**”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。

##### 2xx
“**200 OK**”是最常见的成功状态码，
“**204 No Content**”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。
“**206 Partial Content**”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，“**206 Partial Content**”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，

##### 3xx
“**301 Moved Permanently**”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。
**302 Found**”，曾经的描述短语是“**Moved Temporarily**”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。
“**304 Not Modified**” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）
##### 4xx
“**400 Bad Request**”是一个通用的错误码，表示请求报文有错误
“**403 Forbidden**”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。
“**404 Not Found**” ,资源不存在,但现在已经被滥用
**存在明确说明的错误码**
-   405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；
-   406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；
-   408 Request Timeout：请求超时，服务器等待了过长的时间；
-   409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；
-   413 Request Entity Too Large：请求报文里的 body 太大；
-   414 Request-URI Too Long：请求行里的 URI 太大；
-   429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；
-   431 Request Header Fields Too Large：请求头某个字段或总体太大；
- 
##### 5xx
5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。
“**500 Internal Server Error**”与 400 类似，也是一个通用的错误码，
“**501 Not Implemented**”表示客户端请求的功能还不支持
“**502 Bad Gateway**”通常是服务器作为网关或者代理时返回的错误码，
“**503 Service Unavailable**”表示服务器当前很忙，暂时无法响应服务，503 响应报文里通常还会有一个“**Retry-After**”字段，指示客户端可以在多久以后再次尝试发送请求

## Http中实体数据 Body
Http协议需要收发双方确认传输的数据格式是什么
使用MIME type 来表示数据的格式
1. 请求头是Accept字段
2. 响应头是Content-Type字段
为了增强数据传输效率,传输还有可能使用压缩(Encoding type)对数据进行处理
1. 请求头中是Accept-Encoding
2. 响应头中是Content-Encoding
常用压缩有以下三种格式:
1.  gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；
2.  deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；
3.  br：一种专门为 HTTP 优化的新压缩算法（Brotli）。

语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；

字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；

客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；

Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。

```xml
Accept: text/html,application/xml;q=0.9,*/*;q=0.8
```

**内容协商的结果**
内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个**Vary**字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：
```xml
Vary: Accept-Encoding,User-Agent,Accept
```
表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。
Vary 字段可以认为是响应报文的一个特殊的“版本标记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务，

# 进阶篇

## 传输大文件数据
1.  压缩 HTML 等文本文件是传输大文件最基本的方法；
2.  分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；
3.  范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；
4.  也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。

## Http的连接管理

Http分为长连接与短连接,两种连接区分在于请求后通道是否关闭.http0.9旧版本默认是短连接的,每一个请求都需要三次握手和关闭通道,1.0之后版本默认使用长连接.
### 长连接
我们可以手动标明要求使用长连接
请求头中使用**Connection**，值是“**keep-alive**”来申请
如果服务器支持就会在响应报文中增加**Connection: keep-alive** 字段

**长连接得不到关闭会非常耗费性能**
为了解决这个问题:可以从客户端与服务端两方面解决
客户端:
1. 在请求头里加上“**Connection: close**”字段，告诉服务器：“这次通信后就关闭连接”。
2. 在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。

服务端:
增加使用策略例如nginx:
1. 在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。
2. 使用“keepalive_requests”指令

### 头部阻塞
“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。
解决措施:
1. 客户端: 增加并发请求,但存在占用性能问题,可能会被服务端认为恶意请求拒绝
2. 服务端: 域名分片,增加多个域名指向执行服务器,实际增加可容纳并发数量

## 重定向

浏览器无法控制的,为重定向.当返回状态行为3xx,响应报文中存在`Location:` 字段触发,Location字段执行的地址可以为绝对地址,也可以为相对地址(去除域名\端口号后的地址)

**重定向的相关问题**
1. 性能损耗,所有的请求都会走两次
2. 循环跳转: 如果重定向链路设计有问题时会触发:`A->B->c->A`

## Cookie
弥补Http协议无状态的纸条小字段
### Cookie属性的设置
**有效期**
Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。
**Expires**”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。
“**Max-Age**”用的是相对时间，单位是秒.
浏览器会优先采用 Max-Age 计算失效期

**作用域**
**Domain**”和“**Path**”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。

**安全性**
**HttpOnly**”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，

**SameSite**”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。

**Secure**”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。


## 浏览器缓存

1.  缓存是优化系统性能的重要手段，HTTP 传输的每一个环节中都可以有缓存；
2.  服务器使用“Cache-Control”设置缓存策略，常用的是“max-age”，表示资源的有效期；
	1. -   no_store：**不允许缓存**，用于某些变化非常频繁的数据，例如秒杀页面；
	2. no_cache： 可以缓存,但使用之前需要去服务器验证
	3. must-revalidate：缓存没过期就使用,过期了去服务器验证

4.  验证资源是否失效需要使用“条件请求”，常用的是“if-Modified-Since”和“If-None-Match”，收到 304 就可以复用缓存里的资源；
5.  验证资源是否被修改的条件有两个：“Last-modified”和“ETag”，需要服务器预先在响应报文里设置，搭配条件请求使用；
6.  浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷新数据。



## 代理

 HTTP 代理就是客户端和服务器通信链路中的一个中间环节，为两端提供“代理服务”,代理处于中间层，为 HTTP 处理增加了更多的灵活性，可以实现负载均衡、安全防护、数据过滤等功能；

代理服务器需要使用字段“Via”标记自己的身份，多个代理会形成一个列表

如果想要知道客户端的真实 IP 地址，可以使用字段“X-Forwarded-For”和“X-Real-IP”；

专门的“代理协议”可以在不改动原始报文的情况下传递客户端的真实 IP。
“代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式.
v1，它在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。

## 缓存代理

缓存代理是增加了缓存功能的代理服务，缓存源服务器的数据，分发给下游的客户端；
### 服务器端的缓存控制
![[服务器端缓存控制.png]]
区分客户端上的缓存和代理上的缓存，可以使用两个新属性“**private**”和“**public**”
1. “private”表示缓存只能在客户端保存，是用户“私有”的
2. “public”的意思就是缓存完全开放，谁都可以存，谁都可以用

缓存失效后的重新验证也要区分开（即使用条件请求“Last-modified”和“ETag”），
1. “**must-revalidate**”是只要过期就必须回源服务器验证，
2. “**proxy-revalidate**”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。

代理上缓存的生存时间可以使用新的“**s-maxage**”（s 是 share 的意思，注意 maxage 中间没有“-”），只限定在代理上能够存多久，而客户端仍然使用“max_age”。


代理专用的属性“**no-transform**”。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止这样做，不许“偷偷摸摸搞小动作”。

### 客户端的缓存控制

![[客户端缓存控制.png]]
存的生存时间，多了两个新属性“**max-stale**”和“**min-fresh**”。
1. max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。
2. “min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。

### 相关问题
**Vary**  版本标记
同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，“Vary: Accept-Encoding”“Vary: User-Agent”，缓存代理必须要存储这些不同的版本。

**Purge**-缓存清理
-   过期的数据应该及时淘汰，避免占用空间；
-   源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）；
-   有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。
比较常用的一种做法是使用自定义请求方法“PURGE”，发给代理服务器，要求删除 URI 对应的缓存数据。