---
title: austin
url: https://www.yuque.com/weishengcc/hi3vv4/iq1qqv
date: 2023-01-09 09:39:05
permalink: /pages/6d566f/
categories: 
  - Java开发知识
  - 开源项目
tags: 
  - 
author: 
  name: SSF
  link: https://github.com/SSFsystem
---

用于传递消息的服务平台: 来自3Y的开源项目: [austin-gitee地址](https://gitee.com/zhongfucheng/athena) \ [austin-giihub地址](https://github.com/ZhongFuCheng3y/austin)

<a name="NWwA9"></a>

## 项目目录

![](../assets/iq1qqv/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f62356434646664653066313634383035613665383561383634393862306364377e74706c762d6b3375316662706663702d77617465726d61726b2e696d6167653f)

| 包名 | 作用 |
| --- | --- |
| comon | 公共类 |
| cron | 定时任务模块 |
| handler | mq消息消费者,调用短信\邮件等服务 |
| service-api | 服务接口 |
| seervice-api-impl | 服务接口实现 |
| stream | Data获取->DB/Redis/Elasticsearch,  实时流处理模块 |
| support | 支持 |
| datahouse |  数据仓库 处理模块 |
| web | Http接口 |

**中间件接口**

| 中间件名 | 浏览器访问接口 | 连接地址 |
| --- | --- | --- |
| mysql |  | 3306 |
| kafaka | 9000    admin  123456 | 9092 |
| redis |  | 6379  austin |
| apollo | 7002 *apollo  admin* | 7000 |
| grafana  服务器监控 | 3000 |  |
| graylog  日志 | 9009 | 12201 |
| XXL-JOB  定时任务 |&#x20;
&#x20;| 6767 |
| Flink 流处理工具 |  | 8081 |

<a name="XcRZV"></a>

## 项目功能

<a name="kPmR9"></a>

### 项目日志

使用**slf4j**进行连接**logback**

<a name="rqQ8C"></a>

### 去重功能

去重功能在此项目的业务中,属于 ** 平台性** 功能 (在平台上完成)
去重条件:

1. 当用户在5分钟内收到相同信息时
2. 当用户在当天内,收到某渠道消息5次时

<a name="bWz7c"></a>

### 消息发送的流程

接收到请求后,调用对应的业务流程,不同**类型**的消息有不同的处理流程.  于是将业务抽象为**责任链**, 执行责任链得到**责任链上下文**
![微信图片\_20220503115718.jpg](1651550298026-997f3a5c-01a2-4d61-b843-bf7f1a7225d5.jpeg)123

![](1649578461848-1ec0e854-fa32-4905-b7ea-7484e603b47b.jpeg)

<a name="WV1HJ"></a>

### 消费消息

项目消费者的设计为: 不同类型消息消费者有自己的资源池,避免消息消费延误.  **消费者资源池隔离**
根据枚举类不同的消息类型遍历初始化消费者线程池,
接收到消息时从线程池工具中得到对应线程池执行 实现\_Runnable \_接口的类 **Task**
**Task**调用多个方法,最后调用HandlerHolder获取类型对应的Handler执行发送业务

//业务执行流程
![](1649579254594-7d6c2497-bccd-4d14-be8d-274366036c1e.jpeg)

<a name="FPrm5"></a>

### 日志分析

elk- graylog中间件实现
只需要在lockback中设置一下

<a name="IGeGB"></a>

### 延时队列

1. redis将需要延迟的消息放置Redis，通过Timer轮询得到可执行的消息，将可执行的消息放置不同的Topic供业务方自行消费。
2. redis把消息执行的时间定义为key过期的时间，当key触发了过期回调，那说明该消息可执行了
