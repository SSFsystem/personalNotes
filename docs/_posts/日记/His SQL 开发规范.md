
# 索引相关
## 索引

索引与表结构是分开存储的,sql查询语句的执行过程是这样的
1. 根据查询条件去分析,检索字段是否有索引
2. 如果有索引,索引字段是否囊括展示字段
3. 如果没有,根据索引中存储的表数据位置,去查询其他字段(回表)

## 规范
1. 经常出现在Where子句中的字段且过滤性很强的,应该建立索引
2. 经常与其他表进行连接的表,在连接字段上应该建立索引
	1. 嵌套循环连接中的被驱动表和排序合并连接，均应在连接列上创建适合的索引
3. 多列组合后的唯一值多，且这些列经常出现在WHERE子句中(可以考虑复合索引)
4. 复合索引建立要注意索引列的次序，区分度高的字段应放在前面(如何判断复合索引的次序)
	1. 做相等比较的列，尽量放到前边。
	2. 过滤性好的列，尽量放在前边
	3. 出现频率高的列，尽量放在前边
5. 外键列上应创建索引
6. 数据量超过1000的表应该考虑设计索引
7. 避免冗余或重复索引
	1. 合理创建复合索引（避免冗余），index(a, b, c) 相当于 index(a)、index(a, b)、index(a, b, c) 。
8. OLTP系统，慎重使用位图索引
	1. OLTP（在线交易系统）的特点为是DML操作频繁，而位图索引的特点是会因更新一行，而导致多行被锁。因此，其不适合在OLTP系统中使用。
9. 频繁DML(写次数明显超过读次数)的表,不要建立太多的索引
10. 禁止在更新十分频繁、区分度不高的属性上建立索引(Mysql)
11. 在分区表中，合理使用全局索引和本地分区索引
	1. 由于做分区维护操作时可能会导致全局索引失效，影响SQL执行效率，需要更多的维护工作量和维护窗口时间。但全局索引在不限定分区键条件时，查询效率更高。需要结合具体情况，进行相应的设计和使用。
12. 单表索引建议控制在5个以内，单索引字段数不允许超过5个(Mysql) 
	1. 过多的索引会对表的insert、update带来很大的性能影响，从而影响数据库的稳定性。
13. 高并发表的索引设计，应避免索引字段采用单序列生成
	1. 序列值的产生是单调增长（减少）的，会导致插入时，集中于索引的最右（左）侧的叶子块或分支块上，否则容易产生索引争用，降低数据插入效率；
14. WHERE条件表达式两侧的数据类型要一致
15. like子句尽量避免%开头的模糊查询
16. 谨慎用负（反）向查询
	1. NOT、!=、<>、NOT IN、NOT LIKE等，会导致全表扫描

```
not in 改写为外链接
select * from dept where deptno not in (select deptno from emp);

如果没有找到deptno中与其匹配的,那自然就是不包含deptno
 select * from dept e left join emp d on e.deptno=d.deptno where d.deptno is null;

```

17. 不对索引列进行数学运算或函数运算
	1. 尽量把运算施加到条件值上，而不是在条件列上。对于无法避免在索引列上的函数运算，可以通过创建函数索引来解决。但因函数索引上的一些限制和特性，除非必要，不要使用函数索引。














# 存储过程

# Sql编码


# 库表相关