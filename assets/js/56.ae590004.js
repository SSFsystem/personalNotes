(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{379:function(t,e,r){"use strict";r.r(e);var a=r(3),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("是对 **Servlet  "),e("strong",[t._v("的进一步封装,相比于")]),t._v(" Servlet  **时期需要不断 **getParameter  ,**springMvc只要方法上定义对应名的JavaBean,就可以获取到")]),t._v(" "),e("p",[e("a",{attrs:{name:"VYyHa"}})]),t._v(" "),e("h2",{attrs:{id:"处理请求流程-原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理请求流程-原理"}},[t._v("#")]),t._v(" 处理请求流程--原理")]),t._v(" "),e("p",[e("img",{attrs:{src:"1648620309525-1e205a64-be3e-4030-bc52-9bfbac719834.png",alt:"image.png"}})]),t._v(" "),e("ol",[e("li",[t._v("有一个统一处理请求的入口")]),t._v(" "),e("li",[t._v("通过映射器寻找对应请求地址的适配器")]),t._v(" "),e("li",[t._v("找到对应的适配器")]),t._v(" "),e("li",[t._v("拦截器前置处理")]),t._v(" "),e("li",[t._v("处理请求数据")]),t._v(" "),e("li",[t._v("视图解析器处理")]),t._v(" "),e("li",[t._v("拦截器后置处理")])]),t._v(" "),e("p",[e("strong",[t._v("源码级别顺序")]),t._v("\n DispatcherServlet（⼊⼝）->DispatcherServlet.properties（会初始化的对象）- >HandlerMapping（映射器）->HandlerExecutionChain(映射器+拦截器List) ->HttpRequestHandlerAdapter(适 配器)->HttpMessageConverter(数据转换"),e("br"),t._v(" "),e("img",{attrs:{src:"1648621129181-fa0a3edd-746c-4d2a-9b2d-1b8b93d90560.png",alt:"image.png"}}),t._v(" "),e("a",{attrs:{name:"M0jVZ"}})]),t._v(" "),e("h2",{attrs:{id:"拦截器与过滤器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拦截器与过滤器"}},[t._v("#")]),t._v(" 拦截器与过滤器")]),t._v(" "),e("p",[t._v("过滤器是依赖于servlet的,执行逻辑在请求进入tomcat容器后,但请求进入servlet之前进行"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E9%A2%84%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("预处理"),e("OutboundLink")],1),t._v("的；请求结束返回也是，是在servlet处理完后，返回给前端之前\n拦截器可以深入到方法的前后、异常抛出前后等更深层次的程度作处理（这里也在一定程度上论证了拦截器是利用java的"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%8F%8D%E5%B0%84&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("反射"),e("OutboundLink")],1),t._v("机制实现的），所以在Spring框架中，优先使用拦截器\n拦截器先于ApplicationContext加载，所以拦截器无法注入Spring容器管理的bean。\n解决办法：拦截器不使用@Component加载，改为使用@Configuration+@Bean加载。")]),t._v(" "),e("p",[t._v("总结:\n过滤器：用于属性甄别，对象收集（不可改变过滤对象的属性和行为）\n拦截器：用于对象拦截，行为干预（可以改变拦截对象的属性和行为）")]),t._v(" "),e("p",[e("a",{attrs:{name:"FkCF7"}})]),t._v(" "),e("h2",{attrs:{id:"拦截器的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拦截器的使用"}},[t._v("#")]),t._v(" 拦截器的使用")]),t._v(" "),e("p",[t._v("SpringMVC 中的Interceptor 拦截器的主要作用就是拦截用户的 url 请求,并在执行 handler 方法的前中后加入某些特殊请求,比如通过它来进行权限验证，或者是来判断用户是否登陆。\n主要有两种方式:")]),t._v(" "),e("p",[t._v("实现了Spring 的HandlerInterceptor 接口,或者继承实现了HandlerInterceptor接口的类\n实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类")])])}),[],!1,null,null,null);e.default=n.exports}}]);