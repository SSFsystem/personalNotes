(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{346:function(s,a,t){"use strict";t.r(a);var n=t(3),e=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[a("a",{attrs:{name:"gmQtf"}})]),s._v(" "),a("h2",{attrs:{id:"常见集合的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见集合的差异"}},[s._v("#")]),s._v(" 常见集合的差异:")]),s._v(" "),a("ol",[a("li",[s._v("**List:  **存储的元素是有序的,数据内容可重复")]),s._v(" "),a("li",[a("strong",[s._v("Map")]),s._v(":  存储的元素是无序的,内容可重复\t,键不可重复")]),s._v(" "),a("li",[a("strong",[s._v("Set")]),s._v(": 存储元素结构是无序的,不可重复")])]),s._v(" "),a("p",[s._v("list 与 set 集成自Collection 接口 "),a("a",{attrs:{name:"e9PxS"}})]),s._v(" "),a("h2",{attrs:{id:"list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[s._v("#")]),s._v(" List")]),s._v(" "),a("p",[s._v("常见的"),a("strong",[s._v("List")]),s._v("的实现类为 **ArrayList  **与  **LinkedList  **, "),a("strong",[s._v("ArrayList "),a("strong",[s._v("为")]),s._v("数组")]),s._v("结构,"),a("strong",[s._v("LinkedList  "),a("strong",[s._v("是")]),s._v("链表")]),s._v("结构,\n**ArrayList **相比于原生list 实现了动态扩容机制,每次扩容为1.5倍")]),s._v(" "),a("p",[a("strong",[s._v("Vector "),a("strong",[s._v("底层是数组的")]),s._v("线程安全")]),s._v("数据结构,每次扩容为2倍基本不用")]),s._v(" "),a("p",[a("strong",[s._v("线程安全问题")])]),s._v(" "),a("ul",[a("li",[s._v("⽤Collections来将ArrayList来包装⼀下")])]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Collections")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("synchronizedList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("ul",[a("li",[s._v("使用java.util.concurrent包下     **CopyOnWriteArrayList ** 类(保证最终一致性)")])]),s._v(" "),a("p",[s._v("**CopyOnWriteArrayList  **的扩容是通过写时复制机制(cow)完成的的,每次增加和修改都很耗内存,写时加锁,读不加锁")]),s._v(" "),a("p",[a("a",{attrs:{name:"orANT"}})]),s._v(" "),a("h2",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[s._v("#")]),s._v(" Map")]),s._v(" "),a("ul",[a("li",[s._v("HashMap:  ： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链 表则是主要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突 时有了᫾⼤的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如 果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链 表转化为红⿊树，以减少搜索时")]),s._v(" "),a("li",[s._v("LinkedHashMap ： LinkedHashMap 继承⾃ HashMap ，所以它的底层仍然是基于拉链式散 列结构即由数组和链表或红⿊树组成。另外， LinkedHashMap 在上⾯结构的基础上，增加 了⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的 操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析 （JDK1.8）")]),s._v(" "),a("li",[s._v("Hashtable ： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲 突⽽存在的")]),s._v(" "),a("li",[s._v("TreeMap ： 红⿊树（⾃平衡的排序⼆叉树）")])]),s._v(" "),a("p",[a("img",{attrs:{src:"1648619805451-bd9ee6d9-5905-421e-9b7f-22638df8588d.png",alt:"image.png"}}),s._v(" "),a("a",{attrs:{name:"HdhrX"}})]),s._v(" "),a("h2",{attrs:{id:"set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[s._v("#")]),s._v(" set")]),s._v(" "),a("ul",[a("li",[s._v("HashSet （⽆序，唯⼀）: 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素")]),s._v(" "),a("li",[s._v("LinkedHashSet ： LinkedHashSet 是 HashSet 的⼦类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的")]),s._v(" "),a("li",[s._v("LinkedHashMap 其内部是基于 HashMap 实现⼀样， 不过还是有⼀点点区别的 TreeSet （有序，唯⼀）： 红⿊树(⾃平衡的排序⼆⼆叉树)")])]),s._v(" "),a("p",[a("a",{attrs:{name:"HZHDe"}})]),s._v(" "),a("h2",{attrs:{id:"如何选用合适的集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选用合适的集合"}},[s._v("#")]),s._v(" 如何选用合适的集合")]),s._v(" "),a("p",[s._v("需要根据键值对获取值时,就用map 接口下的类,需要排序就用 "),a("strong",[s._v("TreeMap")]),s._v("\n,不需要排序就用** HashMap **,需要线程安全就用 **ConcurrentHashMap  **")]),s._v(" "),a("p",[s._v("保存元素值时,如果要求键唯一,就用**set **,接口的实现 **TreeSet **和 "),a("strong",[s._v("HashSet")]),s._v(" ,不要求就用 "),a("strong",[s._v("List")]),s._v(",接口的实现集合: **ArrayList **, "),a("strong",[s._v("linkedList")])])])}),[],!1,null,null,null);a.default=e.exports}}]);