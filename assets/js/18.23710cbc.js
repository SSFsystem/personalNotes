(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{341:function(t,a,e){"use strict";e.r(a);var r=e(3),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"系统设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统设计"}},[t._v("#")]),t._v(" #系统设计")]),t._v(" "),a("h2",{attrs:{id:"title-微博-feed-流-信息流系统-url-https-www-yuque-com-weishengcc-hi3vv4-zlhazd83nwqgcg9q"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#title-微博-feed-流-信息流系统-url-https-www-yuque-com-weishengcc-hi3vv4-zlhazd83nwqgcg9q"}},[t._v("#")]),t._v(" title: 微博 Feed 流/信息流系统？\nurl: https://www.yuque.com/weishengcc/hi3vv4/zlhazd83nwqgcg9q")]),t._v(" "),a("p",[a("a",{attrs:{name:"b8RUk"}})]),t._v(" "),a("h1",{attrs:{id:"什么是feed流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是feed流"}},[t._v("#")]),t._v(" 什么是Feed流")]),t._v(" "),a("p",[t._v("智能推荐信息,简单来说就是能够实时/智能推送信息的数据流。像咱们的朋友圈动态（timeline）、知乎的推荐（智能化推荐 ）、你订阅的 Up 主的动态（timeline）都属于 "),a("strong",[t._v("Feed 流")]),t._v("。 "),a("a",{attrs:{name:"F8qHS"}})]),t._v(" "),a("h1",{attrs:{id:"常见的feed流形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的feed流形式"}},[t._v("#")]),t._v(" 常见的Feed流形式")]),t._v(" "),a("p",[a("a",{attrs:{name:"bEpwz"}})]),t._v(" "),a("h2",{attrs:{id:"纯智能推荐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纯智能推荐"}},[t._v("#")]),t._v(" 纯智能推荐")]),t._v(" "),a("p",[t._v("看到的内容是基于你看过的内容推荐的,例如B站首页,知乎首页,")]),t._v(" "),a("p",[t._v("智能推荐需要依赖 "),a("strong",[t._v("推荐系统")]),t._v(" ，推荐质量的好坏和推荐算法有非常大的关系。")]),t._v(" "),a("p",[t._v("推荐系统的相关文献把它们分成三类："),a("strong",[t._v("协同过滤")]),t._v("（仅使用用户与商品的交互信息生成推荐）系统、"),a("strong",[t._v("基于内容")]),t._v("（利用用户偏好和／或商品偏好）的系统和 "),a("strong",[t._v("混合推荐模型")]),t._v("（使用交互信息、用户和商品的元数据）的系统。")]),t._v(" "),a("p",[t._v("另外，随着深度学习应用的爆发式发展，特别是在计算机视觉、自然语言处理和语音方面的进展，基于深度学习的推荐系统越来越引发大家的关注。循环神经网络（RNN）理论上能够有效地对用户偏好和物品属性的动态性进行建模，基于当前的趋势，预测未来的行为。 "),a("a",{attrs:{name:"uPkec"}})]),t._v(" "),a("h2",{attrs:{id:"纯timeline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纯timeline"}},[t._v("#")]),t._v(" 纯Timeline")]),t._v(" "),a("p",[t._v("例如朋友圈,微博关注状态\n纯 Timeline 这种方式实现起来最简单，直接按照时间排序就行了。")]),t._v(" "),a("p",[t._v("纯 Timeline 这种形式更适用于好友社交领域，用户关注更多的是人发出的内容，而不仅仅是内容。")]),t._v(" "),a("p",[a("a",{attrs:{name:"kqgDb"}})]),t._v(" "),a("h2",{attrs:{id:"智能推荐-timeline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#智能推荐-timeline"}},[t._v("#")]),t._v(" 智能推荐+ TimeLine")]),t._v(" "),a("p",[t._v("智能推荐+Timeline 这个也是目前我觉得比较好的一种方式，实现起来比较简单，同时又能一定程度地避免 “信息茧房” 的问题。")]),t._v(" "),a("p",[a("a",{attrs:{name:"wyFox"}})]),t._v(" "),a("h1",{attrs:{id:"feed流架构设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#feed流架构设计"}},[t._v("#")]),t._v(" Feed流架构设计")]),t._v(" "),a("p",[a("a",{attrs:{name:"XvUnO"}})]),t._v(" "),a("h2",{attrs:{id:"设计系统注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计系统注意事项"}},[t._v("#")]),t._v(" 设计系统注意事项")]),t._v(" "),a("ol",[a("li",[t._v("**实时性: **你关注的人发了微博信息之后，信息需要在短时间之内出现在你的信息流中。")]),t._v(" "),a("li",[a("strong",[t._v("高并发:")]),t._v(" 信息流是微博的主体模块，是用户进入到微博之后最先看到的模块，因此它的并发请求量是最高的，可以达到每秒几十万次请求。")]),t._v(" "),a("li",[t._v("**性能: **信息流拉取性能直接影响用户的使用体验。微博信息流系统中需要聚合的数据非常多。聚合这么多的数据就需要查询多次缓存、数据库、计数器，而在每秒几十万次的请求下，如何保证在 100ms 之内完成这些查询操作，展示微博的信息流呢？这是微博信息流系统最复杂之处，也是技术上最大的挑战。 "),a("a",{attrs:{name:"XbO8X"}})])]),t._v(" "),a("h2",{attrs:{id:"feed流的三种推送设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#feed流的三种推送设计"}},[t._v("#")]),t._v(" Feed流的三种推送设计")]),t._v(" "),a("p",[a("a",{attrs:{name:"LaSaJ"}})]),t._v(" "),a("h3",{attrs:{id:"推模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推模式"}},[t._v("#")]),t._v(" 推模式")]),t._v(" "),a("p",[t._v("用户发送信息后,主动推送动态给关注的人,\n推模式下，我们需要将这个动态插入到每位粉丝对应的 feed 表中，这个存储成本是比较高的。尤其是对于粉丝数量比较多的大 V 来说，每发一条动态，需要存储的数据量实在太大。\n正常情况下，一个微博用户的粉丝大概在 150 左右，挨个写入也还好。不过，微博大 V 的粉丝可能在几百万，几千万，如果挨个给每个写入一条数据的话，是肯定不能接受的！因此，推模式不适合关注者粉丝过多的场景。 "),a("a",{attrs:{name:"jEFD9"}})]),t._v(" "),a("h3",{attrs:{id:"拉模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拉模式"}},[t._v("#")]),t._v(" 拉模式")]),t._v(" "),a("p",[t._v("同于推模式，拉模式下我们是自己主动去拉取动态（拉取你关注的人的动态），然后将这些动态根据相关指标（比如时间、热度）进行实时聚合。")]),t._v(" "),a("p",[t._v("拉模式存储成本虽然降低，但是查询和聚合这两个操作的成本会比较高。尤其是对于单个用户关注了很多人的情况来说，你需要定时获取他关注的所有人的动态然后再做聚合，这个成本可想而知。")]),t._v(" "),a("p",[t._v("另外，拉模式下的数据流的实时性要比推模式差的。 "),a("a",{attrs:{name:"kwhie"}})]),t._v(" "),a("h3",{attrs:{id:"推拉结合模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推拉结合模式"}},[t._v("#")]),t._v(" 推拉结合模式")]),t._v(" "),a("p",[t._v("推拉结合的核心是针对微博大 V 和不活跃用户特殊处理。")]),t._v(" "),a("p",[t._v("首先，我们需要区分出系统哪些用户属于微博大 V（10w 粉丝以上？）。其次，我们需要根据登录行为来判断哪些用户属于不活跃用户。")]),t._v(" "),a("p",[t._v("有了这些数据之后，就好办了！当微博大 V 发送微博的时候，我们仅仅将这条微博写入到活跃用户，不活跃的用户自己去拉取。 "),a("a",{attrs:{name:"DRpYe"}})]),t._v(" "),a("h2",{attrs:{id:"存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[t._v("#")]),t._v(" 存储")]),t._v(" "),a("p",[t._v("通用的存储方案就是 "),a("strong",[t._v("MySQL + Redis")]),t._v(" 。MySQL 永久保存数据， Redis 作为缓存提高热点数据的访问速度。\n如果存储出现瓶颈:\n解决措施有:")]),t._v(" "),a("ol",[a("li",[t._v("redis 集群")]),t._v(" "),a("li",[a("strong",[t._v("读写分离")]),t._v(" 和 "),a("strong",[t._v("分库分表 :")]),t._v(" "),a("ol",[a("li",[t._v("sharding-jdbc（当当）、TSharding（蘑菇街）、MyCAT（基于 Cobar）、Cobar（阿里巴巴")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("推荐使用 sharding-jdbc。 因为，sharding-jdbc 是一款轻量级 Java 框架，以 jar 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。")])]),t._v(" "),a("p",[t._v("如果觉得分库分表比较麻烦的话，可以考虑使用 "),a("a",{attrs:{href:"https://docs.pingcap.com/zh/tidb/stable",target:"_blank",rel:"noopener noreferrer"}},[t._v("TiDB"),a("OutboundLink")],1),t._v(" 这类分布式数据库。")])])}),[],!1,null,null,null);a.default=v.exports}}]);