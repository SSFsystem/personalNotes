(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{398:function(v,_,t){"use strict";t.r(_);var a=t(3),l=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"一-流处理基础概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一-流处理基础概念"}},[v._v("#")]),v._v(" 一:流处理基础概念")]),v._v(" "),_("p",[_("strong",[v._v("数据交换策略:")])]),v._v(" "),_("ol",[_("li",[v._v("点对点处理")]),v._v(" "),_("li",[v._v("广播处理")]),v._v(" "),_("li",[v._v("键值处理\n"),_("strong",[v._v("窗口操作:")]),v._v("\n如果对数据进行处理,需要状态对数据进行收集并缓冲处理,\n如果在无限数据上执行是肯定不行的,需要对数据进行"),_("strong",[v._v("限制")]),v._v("\n窗口类型:")]),v._v(" "),_("li",[v._v("滚动窗口")]),v._v(" "),_("li",[v._v("滑动窗口")]),v._v(" "),_("li",[v._v("会话窗口")])]),v._v(" "),_("p",[_("strong",[v._v("时间语义")])]),v._v(" "),_("ol",[_("li",[v._v("事件时间")]),v._v(" "),_("li",[v._v("处理时间")]),v._v(" "),_("li",[v._v("水位线: 超过此时间就任务,此阶段任务已经结束了")])]),v._v(" "),_("p",[_("strong",[v._v("状态与一致性:")]),v._v("\n流式处理数据是潜在无尽的数据,我们需小心维护缓存的状态数据,一般通常算子只会保留事件的摘要或者概览.\n"),_("strong",[v._v("状态维护的问题")])]),v._v(" "),_("ol",[_("li",[v._v("状态管理: 高效管理并保证不受并发更新影响")]),v._v(" "),_("li",[v._v("状态划分按照类型统一Key进行区分")]),v._v(" "),_("li",[v._v("故障恢复")])]),v._v(" "),_("p",[_("strong",[v._v("任务故障与结果故障")]),v._v("\n执行任务发生故障时,流处理通过不同的"),_("code",[v._v("结果故障")]),v._v("来定义发生故障时的行为.\n"),_("strong",[v._v("流处理设置的故障处理措施")])]),v._v(" "),_("ol",[_("li",[v._v("最多一次: 故障发生时,事件完全不恢复,任意丢弃")]),v._v(" "),_("li",[v._v("至少一次:故障发生时,事件恢复,可能重复执行")]),v._v(" "),_("li",[v._v("精准一次: 故障发生后,数据进行重放,保证只有未执行的事件执行")]),v._v(" "),_("li",[v._v("端对端进准一次: 针对流程上最弱的一环进行处理,需特殊处理")])]),v._v(" "),_("h1",{attrs:{id:"datastream-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#datastream-api"}},[v._v("#")]),v._v(" DataStream Api")]),v._v(" "),_("p",[v._v("DataS tream API 为那些最常见的数据转换操作都提供了对应的转换抽象 ,可以分类为")]),v._v(" "),_("ol",[_("li",[v._v("作用于单个事件的基本转换")]),v._v(" "),_("li",[v._v("针对键值对事件的KeyedStream转换")]),v._v(" "),_("li",[v._v("将多条数据流合并为一条或将一条数据流拆分的转换")]),v._v(" "),_("li",[v._v("对流中事件进行重新组织的分发转换")])]),v._v(" "),_("h2",{attrs:{id:"基本转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本转换"}},[v._v("#")]),v._v(" 基本转换")]),v._v(" "),_("ol",[_("li",[v._v("MapFunction: 类型转换")]),v._v(" "),_("li",[v._v("Filter : 过滤")]),v._v(" "),_("li",[v._v("FlatMap: 类型转换可以数据一个或者多个的转换")])]),v._v(" "),_("h2",{attrs:{id:"键值对转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#键值对转换"}},[v._v("#")]),v._v(" 键值对转换")]),v._v(" "),_("p",[v._v("键值对转换生成的KeyedStream 也可以使用上面的基本转换")]),v._v(" "),_("ol",[_("li",[v._v("KeyBy: 根据某个键进行分组")]),v._v(" "),_("li",[v._v("滚动聚合: 作用到流上,生成一个DataStram聚合结果\n"),_("ol",[_("li",[v._v("sum() 计算指定字段的合")]),v._v(" "),_("li",[v._v("min() 计算指定字段最小值")]),v._v(" "),_("li",[v._v("max() 计算指定字段最大值")]),v._v(" "),_("li",[v._v("minBy() 滚动计算输入流中为止的最小值,返回该值所在的事件")]),v._v(" "),_("li",[v._v("maxBy() 滚动计算输入流中为止的最大值,返回该值所在的事件")])])]),v._v(" "),_("li",[v._v("reduce: 滚动聚合的泛化,每个到来事件都与reduce 进行一次组合")])]),v._v(" "),_("h2",{attrs:{id:"多流转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多流转换"}},[v._v("#")]),v._v(" 多流转换")]),v._v(" "),_("ol",[_("li",[v._v("Union 合并两条或多条类型相同的DataStream,不会去重,以先进先出方式合并")]),v._v(" "),_("li",[v._v("connect():合并 接收DataStream并返回一个ConnectedStream对象")]),v._v(" "),_("li",[v._v("ConnectedStreams 对象提供了 ma （）和 flatMap （） 方法 ，它们分别接收 CoMapFunction CoFlatMapFunction 作为参数。")]),v._v(" "),_("li",[v._v("Split 用来将流分割为两条或多条,可以用来过滤或者复制,分割后利用Select指定名称返回特定的SplitStream对象")])])])}),[],!1,null,null,null);_.default=l.exports}}]);