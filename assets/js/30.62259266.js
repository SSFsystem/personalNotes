(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{354:function(t,s,_){"use strict";_.r(s);var v=_(3),a=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("文档内容来自极客时间45讲")])]),t._v(" "),s("h2",{attrs:{id:"基础知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础知识"}},[t._v("#")]),t._v(" 基础知识")]),t._v(" "),s("h3",{attrs:{id:"sql语句查询的流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sql语句查询的流程"}},[t._v("#")]),t._v(" sql语句查询的流程")]),t._v(" "),s("p",[t._v("整体架构主要分为"),s("code",[t._v("逻辑(service)层")]),t._v(" 与 "),s("code",[t._v("引擎层")])]),t._v(" "),s("p",[t._v("![[架构图.png]]")]),t._v(" "),s("ol",[s("li",[t._v("通过身份信息与mysql建立链接")]),t._v(" "),s("li",[t._v("查询缓存中是否存在,缓存一般设置为关闭,因为表内容变动就会重建缓存")]),t._v(" "),s("li",[t._v("通过分析器,判读查询语义是否有问题")]),t._v(" "),s("li",[t._v("优化器优化查询的选择,是否走索引之类的")]),t._v(" "),s("li",[t._v("执行器调用引擎,返回数据")])]),t._v(" "),s("h3",{attrs:{id:"sql中的日志"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sql中的日志"}},[t._v("#")]),t._v(" sql中的日志")]),t._v(" "),s("p",[s("code",[t._v("redolog (重做日志)")]),t._v(" 和 "),s("code",[t._v("binlog")]),t._v(" 日志\n"),s("code",[t._v("redolog")]),t._v("日志是InnDB 引擎独有的,用于支持事务与故障恢复的日志信息,存储的数据是指在数据结构页上做了什么修改,存储空间有限制,容量满时需擦除之前的记录,\n"),s("code",[t._v("binlog")]),t._v("日志是service层公共的,记录数据逻辑上发生了什么样改变(c字段 +=2),用于定期备份恢复数据的日志,支持追加写.目前常见迁移数据就是采用数据库全量数据+"),s("code",[t._v("binlog")]),t._v("恢复的方式.")]),t._v(" "),s("p",[t._v("![[sql更新流程.png]]")]),t._v(" "),s("h3",{attrs:{id:"事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),s("blockquote",[s("p",[t._v("同事务将要涉及到对同一行数据的更新操作则会触发锁事件")])]),t._v(" "),s("p",[s("strong",[t._v("事务的级别:")])]),t._v(" "),s("ol",[s("li",[t._v("读未提交:")]),t._v(" "),s("li",[t._v("读已提交: 不同事务只能读到已经提交的内容")]),t._v(" "),s("li",[t._v("可重复读: 事务才处理期中,读到的数据与开始时一样,")]),t._v(" "),s("li",[t._v("串行读: 会对操作加锁:"),s("code",[t._v("读锁")]),t._v(" , "),s("code",[t._v("写锁")]),t._v(" ,如果写锁冲突时会串行执行")])]),t._v(" "),s("p",[t._v("InnDB 引擎默认隔离级别就是可重复读，oracle默认级别是可重复读\n"),s("strong",[t._v("可重复读")]),t._v(" 与 "),s("strong",[t._v("读提交")]),t._v(" 的区别主要是：可重复读获取的数据是隔离的，是建立事务时的版本。")]),t._v(" "),s("p",[s("strong",[t._v("事务如何启动")])]),t._v(" "),s("blockquote",[s("p",[t._v("事务不要长期持有,会增加占用空间和内存")])]),t._v(" "),s("ol",[s("li",[t._v("显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit. commit work and chain - 提交语句并自动启动下一个事务。回滚语句 - rollback。")]),t._v(" "),s("li",[t._v("set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。")])]),t._v(" "),s("p",[s("strong",[t._v("查找持续时间超过 60s 的事务")])]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" information_schema"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innodb_trx "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" TIME_TO_SEC"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("timediff"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("trx_started"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[t._v("#")]),t._v(" 索引")]),t._v(" "),s("p",[s("strong",[t._v("索引常见的数据模型")])]),t._v(" "),s("ol",[s("li",[t._v("key/value 的哈希表模型: "),s("strong",[t._v("哈希表这种结构适用于只有等值查询的场景")])]),t._v(" "),s("li",[s("strong",[t._v("有序数组")]),t._v(":只适用于静态存储引擎")]),t._v(" "),s("li",[t._v("二叉搜索树")]),t._v(" "),s("li",[t._v("InnoDB 使用了 B+ 树索引模型")])]),t._v(" "),s("p",[s("strong",[t._v("索引分类")]),t._v(" "),s("strong",[t._v("主键索引")]),t._v("  与 "),s("strong",[t._v("非主键索引")]),t._v("  主键索引存储的是行数据，非主键索引存储的是主键索引的位置。")]),t._v(" "),s("p",[s("strong",[t._v("覆盖索引")]),t._v(":索引可以设置多个字段,如果查询条件和展示条件都在"),s("strong",[t._v("联合索引")]),t._v(" 或"),s("strong",[t._v("主键")]),t._v("中,就不用"),s("strong",[t._v("回表")]),t._v("(去主键索引中查)了\n"),s("strong",[t._v("最左匹配原则:")]),t._v(" 查询条件如果与索引最左N个字段吻合,就会走索引,如果索引字段包括全部展示字段,不会触发回表操作\n"),s("strong",[t._v("索引下推")]),t._v(" : 关于最左匹配原则,没有匹配到的查询字段在MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉不满足没匹配到字段的查询条件，再进行回表查询，减少回表率，提升检索速度\n"),s("strong",[t._v("实战知识")]),t._v("\ncount（*）与其它统计相比，效率会高吗：基本相差不大\n邮箱账号这种长字符串怎么建立索引：前缀索引/倒叙索引/哈希值索引\n为何删除数据不会缩减空间： 删除数据后，数据删除，但占据空间会设为空。解决办法为创建同名新表转移数据")]),t._v(" "),s("h3",{attrs:{id:"锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),s("h4",{attrs:{id:"分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),s("ol",[s("li",[t._v("全局锁")]),t._v(" "),s("li",[t._v("表锁")]),t._v(" "),s("li",[t._v("行锁")])]),t._v(" "),s("h4",{attrs:{id:"全局锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[t._v("#")]),t._v(" 全局锁")]),t._v(" "),s("p",[t._v("对整个库加锁,禁止写入,修改,定义操作,一般用于数据库备份时使用\n"),s("strong",[t._v("使用风险:")])]),t._v(" "),s("ol",[s("li",[t._v("使用主库备份:无法更新,业务停摆")]),t._v(" "),s("li",[t._v("在从库使用: 如果解析还原binglog日志,导致主从差异")]),t._v(" "),s("li")]),t._v(" "),s("p",[t._v("建议使用官方工具备份:官方自带的逻辑备份工具mysqldump，当mysqldump使用参数--single-transaction的时候，会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。")]),t._v(" "),s("h4",{attrs:{id:"表锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[t._v("#")]),t._v(" 表锁")]),t._v(" "),s("p",[t._v("表级锁分为两种:"),s("code",[t._v("表锁")]),t._v(" ,"),s("code",[t._v("元数据锁(DML)")]),s("br"),t._v(" "),s("strong",[t._v("表锁")]),t._v("一般常见于非InnDB引擎,不支持行锁的引擎中,语法为lock tables ... read/write .可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象.\n"),s("strong",[t._v("元数据锁DML")]),t._v("\n在访问一个表时自动被加上读/写锁,保证表的读写正确.避免便利查询时,表结构发生变动的情况.\n在给表添加字段时,常会因为元数据锁导致数据库宕机挂掉: "),s("code",[t._v("写锁")]),t._v("等待"),s("code",[t._v("读锁")]),t._v("才能执行,但前方"),s("code",[t._v("读锁")]),t._v("可能为长连接一直未关闭,"),s("code",[t._v("写锁")]),t._v("后面的"),s("code",[t._v("读锁")]),t._v("被阻塞,超时后新建的"),s("code",[t._v("读锁")]),t._v("越来越多,导致宕机.")]),t._v(" "),s("p",[t._v("数据增添字段时针对表是否为热点数据进行处理")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("非热点数据:")]),t._v(" 查询information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务,观察表是否存在长事务的连接,手动kill掉此连接")]),t._v(" "),s("li",[s("strong",[t._v("热点表数据:")]),t._v(" 通过 NOWAIT/WAIT n设置等待时间")])]),t._v(" "),s("p",[s("strong",[t._v("wait n")]),t._v("参数表示等待n秒后，能锁则锁，不能锁则返回错误信息"),s("br"),t._v(" "),s("strong",[t._v("nowait")]),t._v("参数表示不等待，我现在能锁则锁，不能锁则直接返回错误")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ALTER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" tbl_name NOWAIT "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("column")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ALTER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" tbl_name WAIT N "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("column")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" \n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h4",{attrs:{id:"行锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[t._v("#")]),t._v(" 行锁")]),t._v(" "),s("p",[t._v("行锁是由各个引擎实现的,针对行数据加锁的操作.\n行锁是在使用时才加上,直到事务提交才释放")]),t._v(" "),s("ol",[s("li",[t._v("将最可能造成锁冲突的地方尽量往后放")])]),t._v(" "),s("p",[s("strong",[t._v("避免死锁检测造成的性能影响")])]),t._v(" "),s("ol",[s("li",[t._v("如果确保业务不会出现死锁,可以临时把死锁检测关掉")]),t._v(" "),s("li",[t._v("控制并发度")])]),t._v(" "),s("h3",{attrs:{id:"事务隔离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离"}},[t._v("#")]),t._v(" 事务隔离")]),t._v(" "),s("p",[t._v("根据事务级别,承认级别不同:")]),t._v(" "),s("ul",[s("li",[t._v("对于可重复读，查询只承认在事务启动前就已经提交完成的数据；")]),t._v(" "),s("li",[t._v("对于读提交，查询只承认在语句启动前就已经提交完成的数据；")])])])}),[],!1,null,null,null);s.default=a.exports}}]);