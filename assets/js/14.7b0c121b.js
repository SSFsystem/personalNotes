(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{337:function(t,_,v){"use strict";v.r(_);var a=v(3),r=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"系统设计怎么做"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统设计怎么做"}},[t._v("#")]),t._v(" 系统设计怎么做")]),t._v(" "),_("h2",{attrs:{id:"_1-问清楚系统具体要求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-问清楚系统具体要求"}},[t._v("#")]),t._v(" 1.问清楚系统具体要求")]),t._v(" "),_("p",[_("strong",[t._v("当面试官给出了系统设计题目之后，一定不要立即开始设计解决方案。")]),t._v(" 你需要先理解系统设计的需求："),_("code",[t._v("功能性需求")]),t._v("和"),_("code",[t._v("非功能性需求")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"_2-对系统进行抽象设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-对系统进行抽象设计"}},[t._v("#")]),t._v(" 2.对系统进行抽象设计")]),t._v(" "),_("p",[t._v("画出系统的抽象架构图，这个抽象架构图中包含了系统的一些组件以及这些组件之间的连接")]),t._v(" "),_("h2",{attrs:{id:"_3-考虑系统目前需要优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-考虑系统目前需要优化"}},[t._v("#")]),t._v(" 3.考虑系统目前需要优化")]),t._v(" "),_("p",[t._v("对系统进行抽象设计之后，你需要思考当前抽象的系统设计有哪些需要优化的点，比如说：")]),t._v(" "),_("p",[t._v("1当前系统部署在一台机器够吗？是否需要部署在多台机器然后进行负载均衡呢？\n2数据库处理速度能否支撑业务需求？是否需要给指定字段加索引？是否需要读写分离？是否需要缓存？\n3数据量是否大到需要分库分表？\n4是否存在安全隐患？\n5系统是否需要分布式文件系统？")]),t._v(" "),_("h2",{attrs:{id:"_4-优化系统抽象设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-优化系统抽象设计"}},[t._v("#")]),t._v(" 4. 优化系统抽象设计")]),t._v(" "),_("p",[t._v("根据 Step 3 中的“系统需要优化的点” 对系统的抽象设计做进一步完善。")]),t._v(" "),_("h1",{attrs:{id:"系统设计相关指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统设计相关指标"}},[t._v("#")]),t._v(" 系统设计相关指标")]),t._v(" "),_("h2",{attrs:{id:"性能相关的指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能相关的指标"}},[t._v("#")]),t._v(" 性能相关的指标")]),t._v(" "),_("h3",{attrs:{id:"响应时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#响应时间"}},[t._v("#")]),t._v(" 响应时间")]),t._v(" "),_("p",[_("strong",[t._v("响应时间RT(Response-time)就是用户发出请求到用户收到系统处理结果所需要的时间。")])]),t._v(" "),_("p",[t._v("RT是一个非常重要且直观的指标，RT数值大小直接反应了系统处理用户请求速度的快慢")]),t._v(" "),_("h3",{attrs:{id:"并发数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发数"}},[t._v("#")]),t._v(" 并发数")]),t._v(" "),_("p",[_("strong",[t._v("并发数可以简单理解为系统能够同时供多少人访问使用也就是说系统同时能处理的请求数量。")])]),t._v(" "),_("p",[t._v("并发数反应了系统的负载能力。")]),t._v(" "),_("h3",{attrs:{id:"qps-和tps"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#qps-和tps"}},[t._v("#")]),t._v(" QPS 和TPS")]),t._v(" "),_("p",[t._v("●"),_("strong",[t._v("QPS（Query Per Second）")]),t._v(" ：服务器每秒可以执行的查询次数；\n●"),_("strong",[t._v("TPS（Transaction Per Second）")]),t._v(" ：服务器每秒处理的事务数（这里的一个事务可以理解为客户发出请求到收到服务器的过程）；")]),t._v(" "),_("p",[t._v("书中是这样描述 QPS 和 TPS 的区别的。")]),t._v(" "),_("blockquote",[_("p",[t._v("QPS vs TPS：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。")])]),t._v(" "),_("h3",{attrs:{id:"吞吐量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#吞吐量"}},[t._v("#")]),t._v(" 吞吐量")]),t._v(" "),_("p",[_("strong",[t._v("吞吐量指的是系统单位时间内系统处理的请求数量。")])]),t._v(" "),_("p",[t._v("一个系统的吞吐量与请求对系统的资源消耗等紧密关联。请求对系统资源消耗越多，系统吞吐能力越低，反之则越高。")]),t._v(" "),_("p",[t._v("TPS、QPS都是吞吐量的常用量化指标。")]),t._v(" "),_("p",[t._v("●"),_("strong",[t._v("QPS（TPS）")]),t._v(" = 并发数/平均响应时间(RT)\n●"),_("strong",[t._v("并发数")]),t._v(" = QPS * 平均响应时间(RT)")]),t._v(" "),_("h2",{attrs:{id:"系统活跃度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统活跃度"}},[t._v("#")]),t._v(" 系统活跃度")]),t._v(" "),_("h3",{attrs:{id:"pv"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pv"}},[t._v("#")]),t._v(" PV")]),t._v(" "),_("p",[t._v("访问量, 即页面浏览量或点击量，衡量网站用户访问的网页数量；在一定统计周期内用户每打开或刷新一个页面就记录1次，多次打开或刷新同一页面则浏览量累计。UV 从网页打开的数量/刷新的次数的角度来统计的。")]),t._v(" "),_("h3",{attrs:{id:"uv"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#uv"}},[t._v("#")]),t._v(" UV")]),t._v(" "),_("p",[t._v("独立访客，统计1天内访问某站点的用户数。1天内相同访客多次访问网站，只计算为1个独立访客。UV 是从用户个体的角度来统计的。")]),t._v(" "),_("h3",{attrs:{id:"dau"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dau"}},[t._v("#")]),t._v(" DAU")]),t._v(" "),_("p",[t._v("日活跃用户数量。")]),t._v(" "),_("h3",{attrs:{id:"mau"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mau"}},[t._v("#")]),t._v(" MAU")]),t._v(" "),_("p",[t._v("月活跃用户人数。")]),t._v(" "),_("p",[t._v("举例：某网站 DAU为 1200w， 用户日均使用时长 1 小时，RT为0.5s，求并发量和QPS。")]),t._v(" "),_("p",[t._v("平均并发量 = DAU（1200w）* 日均使用时长（1 小时，3600秒） /一天的秒数（86400）=1200w/24 = 50w")]),t._v(" "),_("p",[t._v("真实并发量（考虑到某些时间段使用人数比较少） = DAU（1200w）* 日均使用时长（1 小时，3600秒） /一天的秒数-访问量比较小的时间段假设为8小时（57600）=1200w/16 = 75w")]),t._v(" "),_("p",[t._v("峰值并发量 = 平均并发量 * 6 = 300w")]),t._v(" "),_("p",[t._v("QPS = 真实并发量/RT = 75W/0.5=150w/s")]),t._v(" "),_("h2",{attrs:{id:"常用性能测试工具"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用性能测试工具"}},[t._v("#")]),t._v(" 常用性能测试工具")]),t._v(" "),_("h3",{attrs:{id:"后端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#后端"}},[t._v("#")]),t._v(" 后端")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("Jmeter")]),t._v(" ：Apache JMeter 是 JAVA 开发的性能测试工具")]),t._v(" "),_("li",[_("strong",[t._v("LoadRunner")]),t._v("：一款商业的性能测试工具。")]),t._v(" "),_("li",[_("strong",[t._v("Galtling")]),t._v(" ：一款基于Scala 开发的高性能服务器性能测试工具。")]),t._v(" "),_("li",[_("strong",[t._v("ab")]),t._v(" ：全称为 Apache Bench 。Apache 旗下的一款测试工具，非常实用。\n除了 "),_("strong",[t._v("LoadRunner")]),t._v(" 其他几款性能测试工具都是开源免费的")])]),t._v(" "),_("h3",{attrs:{id:"前端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端"}},[t._v("#")]),t._v(" 前端")]),t._v(" "),_("ol",[_("li",[_("p",[_("strong",[t._v("Fiddler")]),t._v("：抓包工具，它可以修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是Web 调试的利器。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("HttpWatch")]),t._v(": 可用于录制HTTP请求信息的工具。")])])]),t._v(" "),_("h2",{attrs:{id:"常见软件的qps"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见软件的qps"}},[t._v("#")]),t._v(" 常见软件的QPS")]),t._v(" "),_("p",[t._v("里给出的 QPS 仅供参考，实际项目需要进行压测来计算。")]),t._v(" "),_("p",[t._v("●"),_("strong",[t._v("Nginx")]),t._v(" ：一般情况下，系统的性能瓶颈基本不会是 Nginx。单机 Nginx 可以达到 "),_("code",[t._v("30w +")]),t._v("。\n●"),_("strong",[t._v("Redis")]),t._v(":  Redis 官方的性能测试报告："),_("a",{attrs:{href:"https://redis.io/topics/benchmarks",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://redis.io/topics/benchmarks"),_("OutboundLink")],1),t._v("  。从报告中，我们可以得出 Redis 的单机 QPS 可以达到"),_("code",[t._v("8w+")]),t._v("（CPU性能有关系，也和执行的命令也有关系比如执行 SET 命令甚至可以达到10w+QPS）。\n●"),_("strong",[t._v("MySQL")]),t._v(":  MySQL 单机的 QPS 为 大概在 "),_("code",[t._v("4k")]),t._v(" 左右。\n●"),_("strong",[t._v("Tomcat")]),t._v(" ：单机 Tomcat 的QPS 在 "),_("code",[t._v("2w")]),t._v("左右。这个和你的 Tomcat 配置有很大关系，举个例子Tomcat 支持的连接器有 "),_("strong",[t._v("NIO")]),t._v("、"),_("strong",[t._v("NIO.2")]),t._v(" 和 "),_("strong",[t._v("APR")]),t._v("。 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I/O 的，性能更好，Tomcat 配置 APR 为 连接器的话，QPS 可以达到 3w左右。更多相关内容可以自行搜索 Tomcat 性能优化。")]),t._v(" "),_("h2",{attrs:{id:"系统设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统设计原则"}},[t._v("#")]),t._v(" 系统设计原则")]),t._v(" "),_("p",[_("strong",[t._v("合适优于先进 > 演化优于一步到位 > 简单优于复杂")])]),t._v(" "),_("h2",{attrs:{id:"常见的性能优化策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的性能优化策略"}},[t._v("#")]),t._v(" 常见的性能优化策略")]),t._v(" "),_("p",[t._v("性能优化之前我们需要对请求经历的各个环节进行分析，排查出可能出现性能瓶颈的地方，定位问题。")]),t._v(" "),_("p",[t._v("下面是一些性能优化时，经常拿来自问的一些问题：")]),t._v(" "),_("ol",[_("li",[t._v("当前系统的SQL语句是否存在问题?")]),t._v(" "),_("li",[t._v("当前系统是否需要升级硬件？")]),t._v(" "),_("li",[t._v("系统是否需要缓存？")]),t._v(" "),_("li",[t._v("系统架构本身是不是就有问题？")]),t._v(" "),_("li",[t._v("系统是否存在死锁的地方？")]),t._v(" "),_("li",[t._v("数据库索引使用是否合理？")]),t._v(" "),_("li",[t._v("系统是否存在内存泄漏？（Java 的自动回收内存虽然很方便，但是，有时候代码写的不好真的会造成内存泄漏）")]),t._v(" "),_("li",[t._v("系统的耗时操作进行了异步处理？")])]),t._v(" "),_("h2",{attrs:{id:"性能优化必知法则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化必知法则"}},[t._v("#")]),t._v(" 性能优化必知法则")]),t._v(" "),_("p",[_("strong",[t._v("SQL优化，JVM、DB，Tomcat参数调优 > 硬件性能优化（内存升级、CPU核心数增加、机械硬盘—>固态硬盘等等）> 业务逻辑优化/缓存 > 读写分离、集群等 > 分库分表")])]),t._v(" "),_("blockquote",[_("p",[t._v("深入学习系统设计: "),_("a",{attrs:{href:"https://github.com/donnemartin/system-design-primer",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/donnemartin/system-design-primer"),_("OutboundLink")],1),t._v("  。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);