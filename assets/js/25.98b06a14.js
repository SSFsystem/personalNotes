(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{348:function(a,t,s){"use strict";s.r(t);var r=s(3),n=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"1648542885923-6daef2db-9320-4134-a31d-0cc1dccaa938.jpeg",alt:""}}),a._v(" "),t("a",{attrs:{name:"IZVUr"}})]),a._v(" "),t("h2",{attrs:{id:"cas-乐观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas-乐观锁"}},[a._v("#")]),a._v(" cas--乐观锁")]),a._v(" "),t("p",[a._v("意思是:[比较并交换]\ncas设定有三个值: 当前值(A)  内存值(V) 目标值(B),如果当前值与内存值"),t("strong",[a._v("相等")]),a._v(",就将内存值改 目标值,不相等的话,重试或放弃更新\ncas会存在ABA 问题,如果读取到的内存值,经过其他线程修改,最后与读取到的"),t("strong",[a._v("当前值")]),a._v("相等,就会误认为没有修改过.\n推荐使用LongAdder解决(增加版本号)")]),a._v(" "),t("p",[t("a",{attrs:{name:"vPAqz"}})]),a._v(" "),t("h2",{attrs:{id:"synchronized-互斥锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-互斥锁"}},[a._v("#")]),a._v(" synchronized--互斥锁")]),a._v(" "),t("p",[a._v("一次只允许一个线程进入被锁住的代码块")]),a._v(" "),t("ol",[t("li",[a._v("修饰方法,锁对应的是对象实例")]),a._v(" "),t("li",[a._v("修饰静态方法,锁对应的是当前类,class实例")]),a._v(" "),t("li",[a._v("修饰的代码块,锁对应的是传入synchronized的对象实例")])]),a._v(" "),t("p",[a._v("无论synchronized修饰的是方法还是代码块,对应的锁都是一个对象实例 "),t("a",{attrs:{name:"ku5R3"}})]),a._v(" "),t("h3",{attrs:{id:"实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[a._v("#")]),a._v(" 实现原理")]),a._v(" "),t("p",[a._v("在内存中, java对象由三部分组成; "),t("strong",[a._v("对象头\\对象实际数据\\对齐")]),a._v(" "),t("strong",[a._v("对象头")]),a._v(" 又由几部分组成,对象头**Mark Work **记录关于锁的信息,每个对象都有一个对应的monitor对象,monitor对象中存储着当前持有锁的线程,以及等待锁的线程队列\n**Mark Work **记录锁的状态有四种: 无锁  偏向锁  轻量级锁  重量级锁\n每次cas操作自旋获取锁失败到一定次数就会升级")]),a._v(" "),t("p",[t("a",{attrs:{name:"dE7Sq"}})]),a._v(" "),t("h2",{attrs:{id:"aqs-独占-共享"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aqs-独占-共享"}},[a._v("#")]),a._v(" AQS -- 独占 --共享")]),a._v(" "),t("p",[a._v("实现锁的一个框架,内部实现的关键是维护了一个先进先出的队列与state状态的变量.\nAqs支持两种模式独占与共享\nReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore这些常用的实现类都是\n基于AQS实现的 "),t("a",{attrs:{name:"sd2IE"}})]),a._v(" "),t("h3",{attrs:{id:"实现原理-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-2"}},[a._v("#")]),a._v(" 实现原理:")]),a._v(" "),t("p",[a._v("内部维护了一个先进先出的队列,与一个表示State状态的变量\n这个队列是的载体叫node节点,该节点标识当前的状态值, 是独占还是共享模式以及它的前 驱和后继节点等等信息\n"),t("img",{attrs:{src:"1650175688985-51865061-c771-41fe-b15d-a64ca5ab801f.png",alt:"image.png"}})])])}),[],!1,null,null,null);t.default=n.exports}}]);