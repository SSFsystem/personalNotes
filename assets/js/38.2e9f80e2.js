(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{361:function(t,a,e){"use strict";e.r(a);var r=e(3),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("hr"),t._v(" "),a("h2",{attrs:{id:"title-多线程学习与记录url-https-www-yuque-com-weishengcc-hi3vv4-ykyyt8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#title-多线程学习与记录url-https-www-yuque-com-weishengcc-hi3vv4-ykyyt8"}},[t._v("#")]),t._v(" title: 多线程学习与记录\nurl: https://www.yuque.com/weishengcc/hi3vv4/ykyyt8")]),t._v(" "),a("p",[t._v("一:线程基础")]),t._v(" "),a("p",[a("strong",[t._v("线程与进程")]),t._v(":进程是用来获取资源的单位,线程是用来调配资源的单位,一个进程可能有多个线程运行\n多线程是为了提高程序运行效率.")]),t._v(" "),a("p",[a("a",{attrs:{name:"VTSMs"}})]),t._v(" "),a("h3",{attrs:{id:"线程生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程生命周期"}},[t._v("#")]),t._v(" 线程生命周期")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("NEW")]),t._v(" - 初始状态，一个新创建的线程，还没开始执行。")]),t._v(" "),a("li",[a("strong",[t._v("RUNNABLE")]),t._v(" - 可执行的状态，要么是在执行，要么是一切就绪等待执行，例如等待分配CPU时间。")]),t._v(" "),a("li",[a("strong",[t._v("WAITING")]),t._v(" - 等待状态，等待其他的线程去执行特定的动作，没有时间限制。")]),t._v(" "),a("li",[a("strong",[t._v("TIMED_WAITING")]),t._v(" - 限时等待状态，等待其他的线程去执行特定的动作，这个是在一个指定的时间范围内。")]),t._v(" "),a("li",[a("strong",[t._v("BLOCKED")]),t._v(" - 阻塞状态，等待锁，以便进入同步块儿。")]),t._v(" "),a("li",[a("strong",[t._v("TERMINATED")]),t._v(" - 终止状态，线程执行结束。 "),a("a",{attrs:{name:"WN252"}})])]),t._v(" "),a("h3",{attrs:{id:"线程问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程问题"}},[t._v("#")]),t._v(" 线程问题:")]),t._v(" "),a("p",[a("a",{attrs:{name:"LduQJ"}})]),t._v(" "),a("h4",{attrs:{id:"线程安全问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程安全问题"}},[t._v("#")]),t._v(" 线程安全问题")]),t._v(" "),a("p",[t._v("线程安全问题指的是,内存问题, 线程存在公共区域的数据被其他线程修改,导致数据存在安全问题.\n解决措施:")]),t._v(" "),a("ol",[a("li",[t._v("加锁--保证同时只有一个人访问公共数据   --同步阻塞")]),t._v(" "),a("li",[t._v("cas 操作,,但会有aba问题,数据被修改不知道--非同步阻塞")]),t._v(" "),a("li",[t._v("无同步方案,将线程限制在个线程范围内,这样无需同步也能保证数据不被征用.--ThreadLocal")])]),t._v(" "),a("p",[t._v("使用多线程可能会有以下问题:\n"),a("strong",[t._v("内存泄漏  上下文切换 死锁")])]),t._v(" "),a("p",[a("a",{attrs:{name:"IWgui"}})]),t._v(" "),a("h3",{attrs:{id:"上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文切换"}},[t._v("#")]),t._v(" 上下文切换")]),t._v(" "),a("p",[t._v("一般程序设定的线程数量多于cpu核心数量,cpu采取的是分片方式执行线程,线程间切换就是上下文切换")]),t._v(" "),a("p",[a("a",{attrs:{name:"rXzOE"}})]),t._v(" "),a("h3",{attrs:{id:"死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),a("p",[t._v("多个线程抢占资源: 当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资 源，都不放弃⾃⼰拥有的资源。")]),t._v(" "),a("p",[a("strong",[t._v("解决方式")])]),t._v(" "),a("ol",[a("li",[t._v("固定加锁的顺序，⽐如我们可以使⽤Hash值的⼤⼩来确定加锁的先后")]),t._v(" "),a("li",[t._v("尽可能缩减加锁的范围，等到操作共享变量的时候才加锁。")]),t._v(" "),a("li",[t._v("使⽤可释放的定时锁（⼀段时间申请不到锁的权限了，直接释放掉")])]),t._v(" "),a("p",[a("a",{attrs:{name:"He8pw"}})]),t._v(" "),a("h3",{attrs:{id:"开发中线程安全思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发中线程安全思考"}},[t._v("#")]),t._v(" 开发中线程安全思考")]),t._v(" "),a("p",[a("img",{attrs:{src:"1648538846714-1aba1b65-0cc5-4a45-86b4-abdf0f1285e7.png",alt:"image.png"}})]),t._v(" "),a("ol",[a("li",[a("p",[t._v("能不能保证操作的原⼦性，考虑atomic包下的类够不够我们使⽤。")])]),t._v(" "),a("li",[a("p",[t._v("能不能保证操作的可⻅性，考虑volatile关键字够不够我们使⽤")])]),t._v(" "),a("li",[a("p",[t._v("如果涉及到对线程的控制（⽐如⼀次能使⽤多少个线程，当前线程触发的条件是否依赖其他线程的结果）， 考虑CountDownLatch/Semaphore等等。")])]),t._v(" "),a("li",[a("p",[t._v("如果是集合，考虑java.util.concurrent包下的集合类。")])]),t._v(" "),a("li",[a("p",[t._v("如果synchronized⽆法满⾜，考虑lock包下的类")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v(" \t\t<br /> \t\t\t<br /> \t\t\t\t<br /> \t\t\t\t\t<br /> \t\t\t\t\t\t \t\t\t\t\t\t \t\t\t\t\t\t \t\t\t\t\t\t \t\t\t\t\t\n")])])])])]),t._v(" "),a("p",[a("a",{attrs:{name:"GI53X"}})]),t._v(" "),a("h3",{attrs:{id:"synchronized-关键字和-volatile-关键字的区别-synchronized-关键字和-volatile-关键字是两个互补的存在-而不是对立的存在"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-关键字和-volatile-关键字的区别-synchronized-关键字和-volatile-关键字是两个互补的存在-而不是对立的存在"}},[t._v("#")]),t._v(" synchronized 关键字和 volatile 关键字的区别 synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在!")]),t._v(" "),a("p",[a("strong",[t._v("volatile 关键字")]),t._v("是线程同步的"),a("strong",[t._v("轻量级实现")]),t._v("，所以 "),a("strong",[t._v("volatile 性能肯定比 synchronized 关键字 要好")]),t._v("。但是 "),a("strong",[t._v("volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码 块")]),t._v("。\n**volatile 关键字能保证数据的可⻅性，但不能保证数据的原子性。 synchronized 关键字两 者都能保证。 **\n**volatile 关键字主要用于解决变量在多个线程之间的可⻅性，而 synchronized 关键字解决 的是多个线程之间访问资源的同步性。 **\n \t\t\t\t\n \t\t\t\n \t\t")]),t._v(" "),a("p",[a("a",{attrs:{name:"HeSBx"}})]),t._v(" "),a("h3",{attrs:{id:"常见实现多线程的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见实现多线程的方式"}},[t._v("#")]),t._v(" 常见实现多线程的方式")]),t._v(" "),a("p",[t._v("区别: Thrad 类不适合资源的共享, Runnable接口适合资源共享")]),t._v(" "),a("ol",[a("li",[t._v("继承Thrad 类")]),t._v(" "),a("li",[t._v("实现Runnable接口")]),t._v(" "),a("li",[t._v("有返回值的线程操作,实现Callable 接口,搭配线程池使用.返回Future对象")])]),t._v(" "),a("p",[a("a",{attrs:{name:"hb9xL"}})]),t._v(" "),a("h3",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("p",[a("a",{attrs:{name:"RWEUy"}})]),t._v(" "),a("h2",{attrs:{id:"二-线程池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-线程池"}},[t._v("#")]),t._v(" 二:线程池")]),t._v(" "),a("blockquote",[a("p",[t._v("JVM在HotSpot的线程模型下，Java线程会⼀对⼀映射为内核线程  ,线程的创建与销毁会浪费大量时间,线程池为提高线程的复用性,以及固定线程的数量")])]),t._v(" "),a("p",[t._v("**ThreadPoolExecutor   "),a("strong",[t._v("相比")]),t._v(" Executors  **优点,更能了解线程池的运行规则,避免资源损耗")]),t._v(" "),a("p",[a("img",{attrs:{src:"1648545323605-9751a699-d61c-4637-9d4b-08de4dcb4d95.png",alt:"image.png"}})]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("参数名")]),t._v(" "),a("th",[t._v("参数内容")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("corePoolSize")]),t._v(" "),a("td",[t._v("核心线程数量")])]),t._v(" "),a("tr",[a("td",[t._v("maximumPoolSize")]),t._v(" "),a("td",[t._v("最高线程数量")])]),t._v(" "),a("tr",[a("td",[t._v("keepAliveTime")]),t._v(" "),a("td",[t._v("当线程数大于核心时，这是多余的空闲线程在终止前等待新任务的最长时间")])]),t._v(" "),a("tr",[a("td",[t._v("unit")]),t._v(" "),a("td",[t._v("keepAliveTime参数的时间单位")])]),t._v(" "),a("tr",[a("td",[t._v("workQueue")]),t._v(" "),a("td",[t._v("用于在执行任务之前保存任务的队列。此队列将仅保存由execute方法提交的Runnable任务。")])]),t._v(" "),a("tr",[a("td",[t._v("threadFactory")]),t._v(" "),a("td",[t._v("执行器创建新线程时使用的工厂")])]),t._v(" "),a("tr",[a("td",[t._v("handler")]),t._v(" "),a("td",[t._v("由于达到线程边界和队列容量而阻塞执行时使用的处理程序")])])])]),t._v(" "),a("p",[a("a",{attrs:{name:"QhYzj"}})]),t._v(" "),a("h2",{attrs:{id:"三-threadlocal-线程共享变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-threadlocal-线程共享变量"}},[t._v("#")]),t._v(" 三: ThreadLocal  线程共享变量")]),t._v(" "),a("p",[t._v("数据结构\n"),a("img",{attrs:{src:"1648606210420-6ad94b04-ed8a-44e1-86f3-ad67b9fa59c8.png",alt:"image.png"}})]),t._v(" "),a("ul",[a("li",[t._v("**什么是ThreadLocal：**它提供了线程的局部变量，每个线程都可以通过set/get来对这个局部变量进⾏操作， 不会和其他线程的局部变量进⾏冲突，实现了线程的数据隔离。")]),t._v(" "),a("li",[t._v("**ThreadLocal实际⽤处（举例）：**Spring事务，ThreadLocal⾥存储Map，Key是DataSource，Value是 Connection")]),t._v(" "),a("li",[t._v("**ThreadLocal设计：**Thread有ThreadLocalMap引⽤，ThreadLocal作为ThreadLocalMap的Key，set和get 进去的Value则是ThreadLocalMap的value")]),t._v(" "),a("li",[t._v("** ThreadLocal内存泄露**：ThreadLocal被回收&&线程被复⽤&&线程复⽤后不再调⽤ThreadLocal的 set/get/remove⽅法 才可能发⽣内存泄露（条件还是相对苛刻）")]),t._v(" "),a("li",[a("strong",[t._v("ThreadLocal最佳实践")]),t._v("：⽤完就要remove掉")])]),t._v(" "),a("p",[a("a",{attrs:{name:"OIPbm"}})]),t._v(" "),a("h2",{attrs:{id:"四-completablefuture-异步编排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-completablefuture-异步编排"}},[t._v("#")]),t._v(" 四： CompletableFuture 异步编排")]),t._v(" "),a("p",[a("a",{attrs:{name:"R9aJ8"}})]),t._v(" "),a("h4",{attrs:{id:"_4-1-创建异步对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-创建异步对象"}},[t._v("#")]),t._v(" 4.1：创建异步对象")]),t._v(" "),a("p",[t._v("CompletableFuture 提供了四个静态方法来创建一个异步操作\n"),a("img",{attrs:{src:"1648605697886-1048b665-14f3-4ed3-be81-b1c2bbb39c5e.png",alt:"image.png"}}),t._v("\n1、"),a("strong",[t._v("runXxx 都是没有返回结果的，supplyXxxx都是可以获取返回结果的")]),t._v("\n2、可以传入自定义的线程池，否则就是用默认的线程池\n3、根据方法的返回类型来判断是否该方法是否有返回类型 "),a("a",{attrs:{name:"PGtgr"}})]),t._v(" "),a("h4",{attrs:{id:"_4-2计算完成时回调方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2计算完成时回调方法"}},[t._v("#")]),t._v(" 4.2计算完成时回调方法")]),t._v(" "),a("p",[a("img",{attrs:{src:"1648605731988-eef8093c-9428-4f5e-8925-596e25607436.png",alt:"image.png"}}),t._v("\nwhenComplete 可以处理正常和异常的计算结果，exceptionally 处理异常情况\nwhenComplete 和 whenCompleteAsync 的区别\n\t\twhenComplete ：是执行当前任务的线程继续执行 whencomplete 的任务\n\t\twhenCompleteAsync： 是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行\n"),a("strong",[t._v("方法不以 Async 结尾，意味着 Action 使用相同的线程执行，而 Async 可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）")]),t._v(" "),a("a",{attrs:{name:"YgbwW"}})]),t._v(" "),a("h4",{attrs:{id:"_4-3-handle-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-handle-方法"}},[t._v("#")]),t._v(" 4.3 handle 方法")]),t._v(" "),a("p",[t._v("和 complete 一样，可以对结果做最后的处理（可处理异常），可改变返回值\n"),a("img",{attrs:{src:"1648605813917-7be49b9f-7b8e-4fcf-9bb3-636f8d5be46d.png",alt:"image.png"}}),t._v(" "),a("a",{attrs:{name:"RxwBZ"}})]),t._v(" "),a("h4",{attrs:{id:"_4-4-线程串行方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-线程串行方法"}},[t._v("#")]),t._v(" 4.4 线程串行方法;")]),t._v(" "),a("p",[a("img",{attrs:{src:"1648605852597-74ad8438-57f0-4445-9cf2-a715706b61e2.png",alt:"image.png"}})]),t._v(" "),a("p",[t._v("thenApply 方法："),a("strong",[t._v("当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任物的返回值")]),t._v("\nthenAccept方法："),a("strong",[t._v("消费处理结果，接受任务处理结果，并消费处理，无返回结果")]),t._v("\nthenRun 方法："),a("strong",[t._v("只要上面任务执行完成，就开始执行 thenRun ,只是处理完任务后，执行 thenRun的后续操作")]),t._v(" "),a("a",{attrs:{name:"NG0ZC"}})]),t._v(" "),a("h4",{attrs:{id:"_4-5-任务组合-都要完成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-任务组合-都要完成"}},[t._v("#")]),t._v(" 4.5 任务组合-都要完成")]),t._v(" "),a("p",[a("img",{attrs:{src:"1648605924024-d4b91850-16fa-4dd3-9f85-e648e6538c02.png",alt:"image.png"}}),t._v("\n两个任务必须都完成，触发该任务\nthenCombine: 组合两个 future，获取两个 future的返回结果，并返回当前任务的返回值\nthenAccpetBoth: 组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有返回值\nrunAfterBoth:组合 两个 future，不需要获取 future 的结果，只需要两个 future处理完成任务后，处理该任务， "),a("a",{attrs:{name:"j8MZi"}})]),t._v(" "),a("h4",{attrs:{id:"_4-6-任务组合-一个完成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-任务组合-一个完成"}},[t._v("#")]),t._v(" 4.6 任务组合-一个完成")]),t._v(" "),a("p",[a("img",{attrs:{src:"1648605947249-7721bd3b-9e2e-452d-aeef-a51a67fd448d.png",alt:"image.png"}}),t._v(" "),a("a",{attrs:{name:"ui5lr"}})]),t._v(" "),a("h4",{attrs:{id:"当两个任务中-任意一个future-任务完成时-执行任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当两个任务中-任意一个future-任务完成时-执行任务"}},[t._v("#")]),t._v(" 当两个任务中，任意一个future 任务完成时，执行任务")]),t._v(" "),a("p",[a("strong",[t._v("applyToEither")]),t._v(";两个任务有一个执行完成，获取它的返回值，处理任务并有新的返回值\n"),a("strong",[t._v("acceptEither")]),t._v(": 两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值\n"),a("strong",[t._v("runAfterEither")]),t._v(":两个任务有一个执行完成，不需要获取 future 的结果，处理任务，也没有返回值")]),t._v(" "),a("p",[a("a",{attrs:{name:"DDefP"}})]),t._v(" "),a("h4",{attrs:{id:"_4-7-多任务组合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-多任务组合"}},[t._v("#")]),t._v(" 4.7 多任务组合")]),t._v(" "),a("p",[a("img",{attrs:{src:"1648605980722-39ecd192-a23e-40c6-aa3a-de454e3f671f.png",alt:"image.png"}}),t._v("\nallOf："),a("strong",[t._v("等待所有任务完成")]),t._v("\nanyOf:"),a("strong",[t._v("只要有一个任务完成")])])])}),[],!1,null,null,null);a.default=v.exports}}]);